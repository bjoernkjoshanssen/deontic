import Mathlib.Order.SetNotation
import Mathlib.Data.Set.Basic
import Mathlib.Tactic
import Deontic.Venn
/-!
# Lemma II.2.2

We prove Lemma II.2.2 from [Carmo and Jones 2022].

We show that Observation 5.2 is correct except that the example
does not satisfy 5(e).
-/

open Set

-- Carmo and Jones' axioms
def CJ5a {U : Type*} (ob : Set U ‚Üí Set (Set U)) :=
    ‚àÄ (X : Set U), ‚àÖ ‚àâ ob X

def CJ5b {U : Type*} (ob : Set U ‚Üí Set (Set U)) :=
  ‚àÄ (X Y Z : Set U), Z ‚à© X = Y ‚à© X ‚Üí (Z ‚àà ob X ‚Üî Y ‚àà ob X)

/- This is the old one from 2002.
 def CJ5c (ob : Set U ‚Üí Set (Set U)) :=
 ‚àÄ (X Y Z : Set U), Y ‚àà ob X ‚Üí (Z ‚àà ob X ‚Üí Y ‚à© Z ‚àà ob X)
-/

def CJ5c_star {U : Type*} (ob : Set U ‚Üí Set (Set U)) :=
  ‚àÄ (X : Set U) (Œ≤ : Set (Set U)),
  (h1 : Œ≤ ‚äÜ ob X) ‚Üí (h2 : Œ≤ ‚â† ‚àÖ) ‚Üí ‚ãÇ‚ÇÄŒ≤ ‚à© X ‚â† ‚àÖ ‚Üí ‚ãÇ‚ÇÄŒ≤ ‚àà ob X

def CJ5c_star_finite {U : Type*} (ob : Set U ‚Üí Set (Set U)) :=
  ‚àÄ (X : Set U) (Y Z : (Set U)),
  (Y ‚àà ob X) ‚Üí (Z ‚àà ob X) ‚Üí (X ‚à© Y ‚à© Z ‚â† ‚àÖ) ‚Üí (Y ‚à© Z) ‚àà ob X

def CJ5d {U : Type*} (ob : Set U ‚Üí Set (Set U)) :=
  ‚àÄ (X Y Z : Set U), Y ‚äÜ X ‚Üí Y ‚àà ob X ‚Üí X ‚äÜ Z ‚Üí (Z \ X) ‚à™ Y ‚àà ob Z

def CJ5e {U : Type*} (ob : Set U ‚Üí Set (Set U)) :=
  ‚àÄ (X Y Z : Set U), Y ‚äÜ X ‚Üí Z ‚àà ob X ‚Üí Y ‚à© Z ‚â† ‚àÖ ‚Üí Z ‚àà ob Y

def CJ5bd {U : Type*} (ob : Set U ‚Üí Set (Set U)) :=
  ‚àÄ (X Y Z : Set U), Y ‚àà ob (X) ‚àß X ‚äÜ Z ‚Üí (Z \ X) ‚à™ Y ‚àà ob Z

theorem bdImpliesD {U : Type*} (ob : Set U ‚Üí Set (Set U))
    (h : CJ5bd ob) : CJ5d ob := by
  unfold CJ5d
  unfold CJ5bd at h
  intro X Y Z h‚ÇÄ h‚ÇÅ h‚ÇÇ
  apply h; tauto

def CJ5f {U : Type*} (ob : Set U ‚Üí Set (Set U)) :=
  ‚àÄ (Œ≤ : Set (Set U)) (_ : Œ≤ ‚â† ‚àÖ) (X : Set U),
  (‚àÄ Z, Z ‚àà Œ≤ ‚Üí  X ‚àà ob Z)  ‚Üí (X ‚àà ob (‚ãÉ‚ÇÄ Œ≤))


def CJ5g {U : Type*}
    (ob : Set U ‚Üí Set (Set U)) :=
  ‚àÄ (X Y Z : Set U), Y ‚àà ob X ‚Üí Z ‚àà ob Y ‚Üí
    X ‚à© Y ‚à© Z ‚â† ‚àÖ ‚Üí Y ‚à© Z ‚àà ob X


--Lemma II.2.1 --
theorem bd5 {U : Type*} {ob : Set U ‚Üí Set (Set U)}
    (b5 : CJ5b ob) (d5 : CJ5d ob) : CJ5bd ob := by
  intro X Y Z h
  have sets_eq : ((Z \ X) ‚à™ (Y ‚à© X)) ‚à© Z = ((Z \ X) ‚à™ Y) ‚à© Z := by
    ext
    simp
    tauto
  have input2 : Y ‚à© X ‚àà ob X :=
    (b5 X Y (Y ‚à© X) (by rw [inter_assoc, inter_self])).mpr h.1
  exact (b5 Z ((Z \ X) ‚à™ Y) ((Z \ X) ‚à™ (Y ‚à© X)) sets_eq).mp
    (d5 X (Y ‚à© X) Z inter_subset_right input2 h.2)


lemma implication_in_ob {U : Type*} {ob : Set U ‚Üí Set (Set U)}
    (b5 : CJ5b ob) (d5 : CJ5d  ob) {Œ≤ : Set (Set U)} {X : Set U}
    (h : X ‚àà ‚ãÇ‚ÇÄ (ob '' Œ≤)) : {(‚ãÉ‚ÇÄ Œ≤ \ Z) ‚à™ X | Z ‚àà Œ≤} ‚äÜ ob (‚ãÉ‚ÇÄ Œ≤) := by
  have h : ‚àÄ Z ‚àà Œ≤, X ‚àà ob Z := by simp at h;exact h
  exact fun _ ‚ü®Y,hY‚ü© => hY.2 ‚ñ∏ bd5 b5 d5 Y X (‚ãÉ‚ÇÄ Œ≤)
    ‚ü®h Y hY.1, fun _ hy => mem_sUnion.mpr ‚ü®Y,hY.1, hy‚ü©‚ü©

lemma inter_not_empty {U : Type*} {ob : Set U ‚Üí Set (Set U)}
    {Œ≤ : Set (Set U)} {X : Set U} (h2 : Œ≤ ‚â† ‚àÖ)
    (h3 : ‚àÄ Z ‚àà Œ≤, X ‚àà ob Z) (a5 : CJ5a ob) (b5 : CJ5b ob) :
    ‚ãÇ‚ÇÄ {‚ãÉ‚ÇÄ Œ≤ \ Z ‚à™ X | Z ‚àà Œ≤} ‚à© ‚ãÉ‚ÇÄ Œ≤ ‚â† ‚àÖ := by
  obtain ‚ü®Z, hZ‚ü© := exists_mem_of_ne_empty h2
  have hZ2 := h3 Z hZ
  have xz_not_empty : X ‚à© Z ‚â† ‚àÖ := by
    intro hc
    apply a5 Z
    specialize b5 Z ‚àÖ X (by rw [hc,empty_inter])
    apply b5.mp <| h3 _ hZ
  have xz_subset_xh : X ‚à© Z ‚äÜ X ‚à© ‚ãÉ‚ÇÄŒ≤ := fun a ha =>
    ‚ü®ha.1, mem_sUnion.mpr ‚ü®Z,hZ, ha.2‚ü©‚ü©
  rw [‚Üê in_union_yet_in_none' X h2]
  exact fun hi => xz_not_empty <| subset_eq_empty (hi ‚ñ∏ xz_subset_xh) rfl

/-- Lemma II.2.2 Formalized by RJ Reiff. -/
theorem II_2_2 {U : Type} {ob : Set U ‚Üí Set (Set U)} (a5 : CJ5a ob)
    (b5 : CJ5b ob) (cstar5 : CJ5c_star ob) (d5 : CJ5d ob) : CJ5f ob := by
  intro Œ≤ h2 X h3
  rw [in_union_yet_in_none' X h2]
  have h3‚ÇÄ : X ‚àà ‚ãÇ‚ÇÄ (ob '' Œ≤) := by simp; exact h3
  exact cstar5
    (‚ãÉ‚ÇÄ Œ≤) {(‚ãÉ‚ÇÄ Œ≤ \ Z) ‚à™ X | Z ‚àà Œ≤}
    (implication_in_ob b5 d5 h3‚ÇÄ)
    (not_empty X h2)
    (inter_not_empty h2 h3 a5 b5)


/--

Lemma II-2-1
Assuming condition (5b), the following condition below is equivalent to (5d):
(5bd) if Y‚ààob(X) and X‚äÜZ, then ((Z-X) ‚à™ Y) ‚àà ob(Z)
-/
lemma II_2_1 {U : Type} {ob : Set U ‚Üí Set (Set U)}
    (b5 : CJ5b ob) : CJ5d ob ‚Üî CJ5bd ob := ‚ü®bd5 b5, by tauto‚ü©



/--
The deduction of (5-g) is as follows:

From `Y ‚àà ob(X)` deduce `((X‚à™Y)-X)‚à™Y)‚ààob(X‚à™Y)`, i.e., `Y‚ààob(X‚à™Y)`
(take into account that `X‚äÜ(X‚à™Y)`, and use lemma II-2-1 of [2]);

Analogously, from `Z‚ààob(X)` deduce `((X‚à™Y)-Y)‚à™Z)‚ààob(X‚à™Y)`, i.e., `((X-Y)‚à™Z)‚ààob(X‚à™Y)`;

Since `X‚à©Y‚à©Z‚â†‚àÖ`, we have that `Y‚à©((X-Y)‚à™Z)‚à©(X‚à™Y) = Y‚à©Z ‚â† ‚àÖ`, and so, by condition (5-c),
`Y‚à©((X-Y)‚à™Z))‚ààob(X‚à™Y)`, i.e., `Y‚à©Z‚ààob(X‚à™Y)`;

But then, from `Y‚à©Z‚ààob(X‚à™Y)`, `X‚äÜ(X‚à™Y)` and `X‚à©Y‚à©Z‚â†‚àÖ`, by condition (5-e),
it follows that `Y‚à©Z‚ààob(X)` (as we wish to prove).
(Formalized May 26, 2025.)
-/
theorem Observation_5_1_2 {U : Type} {ob : Set U ‚Üí Set (Set U)}
    (b5 : CJ5b ob) (cstar5 : CJ5c_star ob) (d5 : CJ5d ob) (e5: CJ5e ob) :
    CJ5g ob := by
  intro X Y Z h‚ÇÄ h‚ÇÅ h‚ÇÇ
  have g‚ÇÄ : CJ5bd ob := @bd5 U ob b5 d5
  have h‚ÇÄ : ((X ‚à™ Y) \ X) ‚à™ Y ‚àà ob (X‚à™Y) := by
    apply g‚ÇÄ
    tauto
  have h‚ÇÅ : Y ‚àà ob (X‚à™Y) := by
    convert h‚ÇÄ
    ext;simp;tauto
  have h‚ÇÜ : ((X ‚à™ Y) \ Y) ‚à™ Z ‚àà ob (X‚à™Y) := by
    apply g‚ÇÄ
    tauto
  have h‚ÇÖ : Y ‚à© Z ‚â† ‚àÖ := by
    revert h‚ÇÇ
    contrapose!
    intro h
    ext i
    simp
    intro g‚ÇÄ g‚ÇÅ g‚ÇÇ
    have : i ‚àà Y ‚à© Z := by simp;tauto
    aesop
  have by5c : Y ‚à© ((X \ Y) ‚à™ Z) ‚àà ob (X‚à™Y) := by
    unfold CJ5c_star at cstar5
    have := @cstar5 (X ‚à™ Y) {Y, X \ Y ‚à™ Z}
      (by
        intro S hS
        simp at hS
        cases hS with
        | inl h => symm at h;subst h;tauto
        | inr h => rw [h];simp at h‚ÇÜ;tauto
        ) (by
          exact Ne.symm (ne_insert_of_not_mem {X \ Y ‚à™ Z} id))
          (by
          revert h‚ÇÇ
          simp
          contrapose!
          intro h
          have h‚ÇÑ : Y ‚à© ((X \ Y) ‚à™ Z) ‚à© (X ‚à™ Y) = Y ‚à© Z  := by
            ext;simp;tauto
          rw [h‚ÇÑ] at h
          rw [inter_assoc]
          rw [h]
          simp)
    simp at this
    tauto
  apply e5
  show X ‚äÜ X ‚à™ Y
  simp
  have : Y ‚à© Z = Y ‚à© (X \ Y ‚à™ Z) := by ext;simp;tauto
  rw [this]
  tauto
  revert h‚ÇÇ
  simp
  contrapose!
  intro h
  rw [‚Üê h]
  exact inter_assoc X Y Z

open Classical
/-- The function ob from Carmo and Jones 2022 Observation 5.2. -/
def observation_5_2 (X : Set (Fin 4)) : Set (Set (Fin 4)) :=
  ite (X ‚à© {0,1} = ‚àÖ)
    {Y | Y ‚à© X = {3}}
    {Y | Y ‚äá {0,1} ‚à© X}


lemma ob52_a : CJ5a observation_5_2 := fun X h => by
  unfold observation_5_2 at h
  by_cases H : X ‚à© {0,1} = ‚àÖ
  rw [H] at h
  simp at h
  revert h
  simp
  apply ne_of_not_superset
  exact fun a ‚Ü¶ a rfl
  rw [if_neg H] at h
  simp at h
  apply H
  rw [inter_comm] at h
  exact h

lemma ob52_b : CJ5b observation_5_2 := fun X Y‚ÇÄ Y‚ÇÅ h‚ÇÄ => by
  unfold observation_5_2
  constructor
  ¬∑ intro h
    simp at h
    by_cases H : X ‚à© {0,1} = ‚àÖ
    ¬∑ rw [H] at h
      simp at h
      rw [H]
      simp
      aesop
    ¬∑ rw [if_neg H] at h ‚ä¢
      simp at h ‚ä¢
      intro i hi
      suffices i ‚àà Y‚ÇÄ ‚à© X by
        aesop
      rw [‚Üê h‚ÇÄ]
      simp
      constructor
      tauto
      simp at hi
      tauto
  ¬∑ intro h
    simp at h
    by_cases H : X ‚à© {0,1} = ‚àÖ
    ¬∑ rw [H] at h
      simp at h
      rw [H]
      simp
      aesop
    ¬∑ rw [if_neg H] at h ‚ä¢
      simp at h ‚ä¢
      intro i hi
      suffices i ‚àà Y‚ÇÅ ‚à© X by
        simp at this
        aesop
      rw [h‚ÇÄ]
      simp
      constructor
      tauto
      simp at hi
      tauto

lemma ob52_c : CJ5c_star observation_5_2 := fun X ùì¢ h‚ÇÄ h‚ÇÅ h‚ÇÇ => by
  obtain ‚ü®S,hS‚ü© : ‚àÉ S, S ‚àà ùì¢ := exists_mem_of_ne_empty h‚ÇÅ
  unfold observation_5_2 at h‚ÇÄ ‚ä¢
  by_cases H : X ‚à© {0,1} = ‚àÖ
  rw [H] at h‚ÇÄ ‚ä¢
  simp at h‚ÇÄ ‚ä¢
  ext i
  simp
  constructor
  ¬∑ intro h
    have := h.1
    have := this S hS
    have := h‚ÇÄ hS
    simp at this
    suffices i ‚àà ({3} : Set (Fin 4)) by
      simp at this
      exact this
    rw [‚Üê this]
    simp
    tauto
  ¬∑ intro h
    subst h
    constructor
    ¬∑ intro T hT
      specialize h‚ÇÄ hT
      simp at h‚ÇÄ
      suffices 3 ‚àà T ‚à© X by exact mem_of_mem_inter_left this
      rw [h‚ÇÄ]
      simp
    ¬∑ specialize h‚ÇÄ hS
      simp at h‚ÇÄ
      suffices 3 ‚àà S ‚à© X by exact mem_of_mem_inter_right this
      rw [h‚ÇÄ]
      simp
  rw [if_neg H] at h‚ÇÄ ‚ä¢
  simp at h‚ÇÄ ‚ä¢
  exact h‚ÇÄ

/-- Surprisingly, 5(e) is NOT true
despite what CJ 2022 claim.
The mistake in the detailed proof supplied on Feb 2, 2022
is that we are in Case 1 and although I'll grant that
Z ‚à© Y ‚äá {0,1} ‚à© Y, this doesn't matter since {0,1} ‚à© Y = ‚àÖ.

-/
lemma ob52_e' : ¬¨ CJ5e observation_5_2 := by
  intro h
  specialize h {0,2} {2} {2,0}
  unfold observation_5_2 at h
  simp at h
  split at h
  next h_1 =>
    simp_all only [Fin.isValue, mem_setOf_eq]
    have : (0 : Fin 4) ‚àà ({0,2} : Set (Fin 4)) ‚à© {0,1} := by simp
    rw [h_1] at this
    simp at this
  next h_1 =>
    simp_all only [Fin.isValue, mem_setOf_eq]
    specialize h (by
      intro j hj
      simp at hj‚ä¢
      fin_cases j <;> tauto)
    have : 2 ‚àà ({2,0} : Set (Fin 4)) ‚à© {2} := by simp
    rw [h] at this
    simp at this

lemma q_in : {0,1} ‚àà observation_5_2 univ:= by
  unfold observation_5_2
  simp
  rw [if_neg (by
    refine nonempty_iff_ne_empty'.mp ?_
    exact instNonemptyElemInsert 0 {1})]
  simp

lemma r_not_in : ¬¨ {0,2} ‚àà observation_5_2 (univ \ {0,1}):= by
  intro hc
  unfold observation_5_2 at hc
  simp at hc
  have : 3 ‚àà ({3} : Set (Fin 4)) := by simp
  rw [‚Üê hc] at this
  simp at this


lemma ob52_g : CJ5g observation_5_2 := by
  unfold CJ5g
  intro X Y Z h‚ÇÄ h‚ÇÅ h‚ÇÇ
  unfold observation_5_2 at *
  by_cases H‚ÇÄ : X ‚à© {0,1} = ‚àÖ
  rw [H‚ÇÄ] at h‚ÇÄ ‚ä¢
  simp_all
  by_cases H‚ÇÅ : Y ‚à© {0,1} = ‚àÖ
  ¬∑ rw [H‚ÇÅ] at h‚ÇÅ
    simp at h‚ÇÅ
    apply subset_antisymm
    apply subset_trans
    show Y ‚à© Z ‚à© X ‚äÜ Z ‚à© Y
    intro;simp;tauto
    exact Eq.subset h‚ÇÅ
    intro i hi
    simp at hi
    subst hi
    simp_all
    constructor
    suffices 3 ‚àà Z ‚à© Y by simp at this;tauto
    rw [h‚ÇÅ]
    simp
    suffices 3 ‚àà Y ‚à© X by simp at this;tauto
    rw [h‚ÇÄ]
    simp
  ¬∑ rw [if_neg H‚ÇÅ] at h‚ÇÅ
    simp at h‚ÇÅ
    apply subset_antisymm
    apply subset_trans
    show Y ‚à© Z ‚à© X ‚äÜ Y ‚à© X
    intro;simp;tauto
    exact Eq.subset h‚ÇÄ
    intro i hi
    simp at hi
    subst hi
    -- simp_all
    constructor
    ¬∑ have : 3 ‚àà Y := by
        suffices 3 ‚àà Y ‚à© X by simp at this;tauto
        rw [h‚ÇÄ]
        simp
      constructor
      tauto
      obtain ‚ü®j,hj‚ü© : ‚àÉ j, j ‚àà X ‚à© Y ‚à© Z := by
        refine nonempty_def.mp ?_
        exact nonempty_iff_ne_empty.mpr h‚ÇÇ
      fin_cases j
      ¬∑ simp at hj
        have : 0 ‚àà X ‚à© {0, 1} := by simp;tauto
        rw [H‚ÇÄ] at this
        simp at this
      ¬∑ simp at hj
        have : 1 ‚àà X ‚à© {0, 1} := by simp;tauto
        rw [H‚ÇÄ] at this
        simp at this
      ¬∑ simp at hj
        have : 2 ‚àà Y ‚à© X := by simp;tauto
        rw [h‚ÇÄ] at this
        simp at this
      ¬∑ simp at hj
        tauto
    ¬∑ suffices 3 ‚àà Y ‚à© X by simp at this;tauto
      rw [h‚ÇÄ]
      simp
  rw [if_neg H‚ÇÄ] at h‚ÇÄ ‚ä¢
  simp at h‚ÇÄ ‚ä¢
  constructor
  ¬∑ tauto
  ¬∑ by_cases H‚ÇÅ : Y ‚à© {0,1} = ‚àÖ
    ¬∑ rw [H‚ÇÅ] at h‚ÇÅ
      simp at h‚ÇÅ
      intro i hi
      fin_cases i
      ¬∑ simp at hi ‚ä¢
        exfalso
        have : 0 ‚àà Y ‚à© {0,1} := by simp;tauto
        rw [H‚ÇÅ] at this
        simp at this
      ¬∑ simp at hi ‚ä¢
        exfalso
        have : 1 ‚àà {0,1} ‚à© X := by simp;tauto
        have : 1 ‚àà Y ‚à© {0,1} := by simp;apply h‚ÇÄ;simp;tauto
        rw [H‚ÇÅ] at this
        simp at this
      ¬∑ simp at hi ‚ä¢
      ¬∑ simp at hi ‚ä¢
    ¬∑ rw [if_neg H‚ÇÅ] at h‚ÇÅ
      simp at h‚ÇÅ
      intro i hi
      apply h‚ÇÅ
      simp at hi ‚ä¢
      constructor
      tauto
      apply h‚ÇÄ
      simp
      constructor
      tauto
      tauto

lemma ob52_f : CJ5f observation_5_2 := by
  unfold CJ5f
  intro ùì¢ hùì¢ X h
  unfold observation_5_2 at h ‚ä¢
  by_cases H‚ÇÄ : ‚ãÉ‚ÇÄ ùì¢ ‚à© {0, 1} = ‚àÖ
  ¬∑ rw [H‚ÇÄ]
    simp
    obtain ‚ü®A,hA‚ü© : ‚àÉ A, A ‚àà ùì¢ := exists_mem_of_ne_empty hùì¢
    have h' := h A hA
    by_cases H‚ÇÅ : A ‚à© {0,1} = ‚àÖ
    ¬∑ rw [H‚ÇÅ] at h'
      apply subset_antisymm
      ¬∑ intro i hi
        fin_cases i
        simp_all
        have : 0 ‚àà ‚ãÉ‚ÇÄ ùì¢ := mem_of_mem_inter_right hi
        have : 0 ‚àà ‚ãÉ‚ÇÄ ùì¢ ‚à© {0, 1} := by simp;tauto
        rw [H‚ÇÄ] at this
        simp at this
        simp_all
        have : 1 ‚àà ‚ãÉ‚ÇÄ ùì¢ := mem_of_mem_inter_right hi
        have : 1 ‚àà ‚ãÉ‚ÇÄ ùì¢ ‚à© {0, 1} := by simp;tauto
        rw [H‚ÇÄ] at this
        simp at this
        simp_all
        obtain ‚ü®T,hT‚ü© := hi.2
        have h'' := h T hT.1
        by_cases H‚ÇÇ : T ‚à© {0,1} = ‚àÖ
        rw [H‚ÇÇ] at h''
        simp at h''
        have : 2 ‚àà X ‚à© T := by simp;tauto
        rw [h''] at this
        simp at this

        rw [if_neg H‚ÇÇ] at h''
        simp at h''

        apply H‚ÇÇ
        apply eq_empty_of_subset_empty
        apply subset_trans
        show T ‚à© {0,1} ‚äÜ ( ‚ãÉ‚ÇÄ ùì¢ ‚à© {0, 1})
        intro i hi
        simp at hi ‚ä¢
        simp_all
        use T
        tauto
        rw [H‚ÇÄ]

        simp at hi ‚ä¢
      ¬∑ intro i hi
        simp at hi
        subst hi
        simp at h ‚ä¢
        constructor
        ¬∑ simp at h'
          suffices 3 ‚àà X ‚à© A by simp at this;aesop
          rw [h']
          simp
        use A
        simp_all
        suffices 3 ‚àà X ‚à© A by simp at this;aesop
        rw [h']
        simp
    ¬∑ rw [if_neg H‚ÇÅ] at h'
      simp at h'
      ext i
      fin_cases i
      ¬∑ simp
        intro hX B hB
        specialize h B hB
        by_cases H‚ÇÇ : B ‚à© {0,1} = ‚àÖ
        ¬∑ -- easy
          intro hc
          have : 0 ‚àà B ‚à© {0,1} := by simp;tauto
          rw [H‚ÇÇ] at this
          simp at this

        ¬∑ intro hc
          rw [if_neg H‚ÇÇ] at h
          simp at h
          have : 0 ‚àà ‚ãÉ‚ÇÄ ùì¢ ‚à© {0, 1} := by
            simp
            use B
          rw [H‚ÇÄ] at this
          simp at this
      ¬∑ simp
        intro hX B hB
        specialize h B hB
        by_cases H‚ÇÇ : B ‚à© {0,1} = ‚àÖ
        ¬∑ -- easy
          intro hc
          have : 1 ‚àà B ‚à© {0,1} := by simp;tauto
          rw [H‚ÇÇ] at this
          simp at this
        ¬∑ intro hc
          rw [if_neg H‚ÇÇ] at h
          simp at h
          have : 1 ‚àà ‚ãÉ‚ÇÄ ùì¢ ‚à© {0, 1} := by
            simp
            use B
          rw [H‚ÇÄ] at this
          simp at this


      ¬∑ exfalso
        apply H‚ÇÅ
        apply eq_empty_of_subset_empty
        apply subset_trans
        show A ‚à© {0,1} ‚äÜ ‚ãÉ‚ÇÄ ùì¢ ‚à© {0, 1}
        simp
        intro i hi
        use A
        constructor
        tauto
        exact hi.1
        rw [H‚ÇÄ]
      ¬∑ exfalso
        apply H‚ÇÅ
        apply eq_empty_of_subset_empty
        apply subset_trans
        show A ‚à© {0,1} ‚äÜ ‚ãÉ‚ÇÄ ùì¢ ‚à© {0, 1}
        simp
        intro i hi
        use A
        constructor
        tauto
        exact hi.1
        rw [H‚ÇÄ]
  ¬∑ rw [if_neg H‚ÇÄ]
    simp
    intro i hi
    simp at hi
    obtain ‚ü®A,hA‚ü© := hi.2
    specialize h A hA.1
    by_cases H‚ÇÅ : A ‚à© {0,1} = ‚àÖ
    rw [H‚ÇÅ] at h
    simp at h
    fin_cases i

    simp_all
    exfalso
    have : 0 ‚àà A ‚à© {0,1} := by simp;tauto
    rw [H‚ÇÅ] at this
    simp at this

    simp_all
    exfalso
    have : 1 ‚àà A ‚à© {0,1} := by simp;tauto
    rw [H‚ÇÅ] at this
    simp at this

    simp_all
    simp_all

    fin_cases i
    ¬∑ simp_all
      aesop
    ¬∑ simp_all
      aesop
    ¬∑ simp_all
    ¬∑ simp_all
